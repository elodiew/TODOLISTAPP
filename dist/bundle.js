/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/javascript/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/javascript/app.js":
/*!*******************************!*\
  !*** ./src/javascript/app.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*global app, $on */\n__webpack_require__(/*! ../javascript/view.js */ \"./src/javascript/view.js\");\n\n__webpack_require__(/*! ../javascript/store.js */ \"./src/javascript/store.js\");\n\n__webpack_require__(/*! ../javascript/model.js */ \"./src/javascript/model.js\");\n\n__webpack_require__(/*! ../javascript/template.js */ \"./src/javascript/template.js\");\n\n__webpack_require__(/*! ../javascript/controller.js */ \"./src/javascript/controller.js\");\n\n__webpack_require__(/*! ../javascript/helpers.js */ \"./src/javascript/helpers.js\");\n\n__webpack_require__(/*! ../javascript/app.js */ \"./src/javascript/app.js\");\n\n(function () {\n  'use strict';\n  /**\n   * Initialise une nouvelle liste de tâche.\n   * @param {string} name Le nom de la nouvelle liste de tâches.\n   */\n\n  function Todo(name) {\n    this.storage = new app.Store(name);\n    this.model = new app.Model(this.storage);\n    this.template = new app.Template();\n    this.view = new app.View(this.template);\n    this.controller = new app.Controller(this.model, this.view);\n  }\n\n  let todo = new Todo('todos-vanillajs');\n\n  function setView() {\n    todo.controller.setView(document.location.hash);\n  }\n\n  $on(window, 'load', setView);\n  $on(window, 'hashchange', setView);\n})();\n\n//# sourceURL=webpack:///./src/javascript/app.js?");

/***/ }),

/***/ "./src/javascript/controller.js":
/*!**************************************!*\
  !*** ./src/javascript/controller.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function (window) {\n  'use strict';\n  /**\n   * CONTROLLER Permet l'intéraction entre le Model et la View\n   * @constructor\n   * @param {object} model L'instance du Model\n   * @param {object} view L'instance de la View\n   */\n\n  class Controller {\n    constructor(model, view) {\n      let self = this;\n      self.model = model;\n      self.view = view;\n      self.view.bind('newTodo', function (title) {\n        self.addItem(title);\n      });\n      self.view.bind('itemEdit', function (item) {\n        self.editItem(item.id);\n      });\n      self.view.bind('itemEditDone', function (item) {\n        self.editItemSave(item.id, item.title);\n      });\n      self.view.bind('itemEditCancel', function (item) {\n        self.editItemCancel(item.id);\n      });\n      self.view.bind('itemRemove', function (item) {\n        self.removeItem(item.id);\n      });\n      self.view.bind('itemToggle', function (item) {\n        self.toggleComplete(item.id, item.completed);\n      });\n      self.view.bind('removeCompleted', function () {\n        self.removeCompletedItems();\n      });\n      self.view.bind('toggleAll', function (status) {\n        self.toggleAll(status.completed);\n      });\n    }\n    /**\n     * Charge et initialise la View\n     * @param {string} 'Peut prendre 3 valeurs : '' / 'active' / 'completed'\n     */\n\n\n    setView(locationHash) {\n      let route = locationHash.split('/')[1];\n      let page = route || '';\n\n      this._updateFilterState(page);\n    }\n\n    /**\n     * Affiche toutes les tâches de la liste en cours\n     */\n    showAll() {\n      let self = this;\n      self.model.read(function (data) {\n        self.view.render('showEntries', data);\n      });\n    }\n\n    /**\n     * Affiche toutes les tâches actives de la liste en cours\n     */\n    showActive() {\n      let self = this;\n      self.model.read({\n        completed: false\n      }, function (data) {\n        self.view.render('showEntries', data);\n      });\n    }\n\n    /**\n     * Affiche toutes les tâches complétées de la liste en cours\n     */\n    showCompleted() {\n      let self = this;\n      self.model.read({\n        completed: true\n      }, function (data) {\n        self.view.render('showEntries', data);\n      });\n    }\n\n    /**\n     * Ajoute une nouvelle tâche dans la liste en cours (insertion dans le DOM et dans le local storage)\n     * @param {string} title Le titre de la tâche ajoutée\n     */\n    addItem(title) {\n      let self = this;\n\n      if (title.trim() === '') {\n        return;\n      }\n\n      self.model.create(title, function () {\n        self.view.render('clearNewTodo');\n\n        self._filter(true);\n      });\n    }\n\n    /**\n     * Déclenche le mode d'édition des éléments.\n     * Active l'édition d'une tâche de la liste en cours\n     *  @param {number} id L'id du model (correspondant à la tâche à éditer)\n     */\n    editItem(id) {\n      let self = this;\n      self.model.read(id, function (data) {\n        self.view.render('editItem', {\n          id: id,\n          title: data[0].title\n        });\n      });\n    }\n\n    /**\n     * Enregistre la nouvelle tâche éditée\n     *  @param {number} id L'id de la tâche éditéez\n     *  @param {string} title Le titre de la tâche éditée\n     */\n    editItemSave(id, title) {\n      let self = this;\n\n      while (title[0] === \" \") {\n        title = title.slice(1);\n      }\n\n      while (title[title.length - 1] === \" \") {\n        title = title.slice(0, -1);\n      }\n\n      if (title.length !== 0) {\n        self.model.update(id, {\n          title: title\n        }, function () {\n          self.view.render('editItemDone', {\n            id: id,\n            title: title\n          });\n        });\n      } else {\n        self.removeItem(id);\n      }\n    }\n\n    /** \n     * Annule l'édition de la tâche en cours \n     * @param {number} idL'id de la tâche éditée\n     */\n    editItemCancel(id) {\n      let self = this;\n      self.model.read(id, function (data) {\n        self.view.render('editItemDone', {\n          id: id,\n          title: data[0].title\n        });\n      });\n    }\n\n    /**\n     * Supprime une tâche de la liste en cours.\n     * @param {number} id L'id de la tâche à supprimer dans le DOM et dans le localStorage\n     */\n    removeItem(id) {\n      let self = this;\n      let items;\n      self.model.read(function (data) {\n        items = data;\n      });\n      self.model.remove(id, function () {\n        self.view.render('removeItem', id);\n        console.log(\"Element with ID: \" + id + \" has been removed.\");\n      });\n\n      self._filter();\n    }\n\n    /**\n     * Supprime toutes les tâches terminées de la liste en cours\n     */\n    removeCompletedItems() {\n      let self = this;\n      self.model.read({\n        completed: true\n      }, function (data) {\n        data.forEach(function (item) {\n          self.removeItem(item.id);\n        });\n      });\n\n      self._filter();\n    }\n\n    /**\n     * Actualise l'affichage de la tâche en fonction de son statut (terminé ou non)\n     * Donnez-lui un identifiant d'un modèle et une case à cocher et il mettra à jour l'article\n     * dans le stockage en fonction de l'état de la case à cocher.\n     * @param {number} id L'id de la tâche (toutes les tâches sont parcourues)\n     * @param {object} checkbox Vérifie si le champ checked est coché ou non\n     * @param {boolean|undefined} silent Empêche le refiltrage des éléments de la liste\n     */\n    toggleComplete(id, completed, silent) {\n      let self = this;\n      self.model.update(id, {\n        completed: completed\n      }, function () {\n        self.view.render('elementComplete', {\n          id: id,\n          completed: completed\n        });\n      });\n\n      if (!silent) {\n        self._filter();\n      }\n    }\n\n    /**\n     * Permet d'activer ou de désactiver les cases cochées\n     * @param {object} completed Les tâches terminées\n     */\n    toggleAll(completed) {\n      let self = this;\n      self.model.read({\n        completed: !completed\n      }, function (data) {\n        data.forEach(function (item) {\n          self.toggleComplete(item.id, completed, true);\n        });\n      });\n\n      self._filter();\n    }\n\n    /**\n     * Met à jour le compteur de tâche en bas à gauche de l'application\n     */\n    _updateCount() {\n      let self = this;\n      self.model.getCount(function (todos) {\n        self.view.render('updateElementCount', todos.active);\n        self.view.render('clearCompletedButton', {\n          completed: todos.completed,\n          visible: todos.completed > 0\n        });\n        self.view.render('toggleAll', {\n          checked: todos.completed === todos.total\n        });\n        self.view.render('contentBlockVisibility', {\n          visible: todos.total > 0\n        });\n      });\n    }\n\n    /**\n     * Refiltre les tâches en fonction de leur statut actif (#active)\n     * @param {boolean|undefined} force  Refiltre les tâches.\n     */\n    _filter(force) {\n      let activeRoute = this._activeRoute.charAt(0).toUpperCase() + this._activeRoute.substr(1); // Mettez à jour les éléments de la page, qui changent à chaque tâche terminée\n\n\n      this._updateCount(); // Si le dernier itinéraire actif n'est pas \"Tous\" ou si nous changeons d'itinéraire, nous\n      // recréez les éléments de l'élément todo, en appelant:\n      //   this.show[All|Active|Completed]();\n\n\n      if (force || this._lastActiveRoute !== 'All' || this._lastActiveRoute !== activeRoute) {\n        this['show' + activeRoute]();\n      }\n\n      this._lastActiveRoute = activeRoute;\n    }\n\n    /**\n     * Met à jour l'url pour filtrer les tâches (ajoute à l'url : /active ou /completed)\n     */\n    _updateFilterState(currentPage) {\n      // \n      // Stocker une référence à l'itinéraire actif, nous permettant de re-filtrer todo\n      // éléments car ils sont marqués comme complets ou incomplets.\n      this._activeRoute = currentPage;\n\n      if (currentPage === '') {\n        this._activeRoute = 'All';\n      }\n\n      this._filter();\n\n      this.view.render('setFilter', currentPage);\n    }\n\n  }\n\n  ; // Exporter vers la window\n\n  window.app = window.app || {};\n  window.app.Controller = Controller;\n})(window);\n\n//# sourceURL=webpack:///./src/javascript/controller.js?");

/***/ }),

/***/ "./src/javascript/helpers.js":
/*!***********************************!*\
  !*** ./src/javascript/helpers.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * NodeList globale\n */\n\n/** @global */\n(function (window) {\n  'use strict';\n  /**\n   * Récupère un élément avec querySelector (qs) et le sélecteur CSS\n   * @param {string} selector Le sélecteur css de l'élément\n   *  @param {string} scope Le scope de l'élément (si pas renseigné, document par défaut)\n   */\n\n  window.qs = function (selector, scope) {\n    return (scope || document).querySelector(selector);\n  };\n  /**\n   * Récupère plusieurs éléments avec querySelectorAll (qsa) et le sélecteur CSS\n   * @param {string} selector Le sélecteur css de l'élément\n   *  @param {string} scope Le scope de l'élément (si pas renseigné, document par défaut)\n   */\n\n\n  window.qsa = function (selector, scope) {\n    return (scope || document).querySelectorAll(selector);\n  };\n  /**\n   * Ajoute un écouteur d'évènement à l'élément ciblé\n   * @param {element} target L'élément ciblé\n   *  @param {string} type Le type de l'évènement (click, change...)\n   *  @param {string} callback La réponse en cas d'évènement\n   *  @param {Boolean} useCapture indique si l'évènement est envoyé au listener enregistré avant d'être distribué à tout EventTarget (https://developer.mozilla.org/fr/docs/Web/API/EventTarget/addEventListener)\n   */\n\n\n  window.$on = function (target, type, callback, useCapture) {\n    target.addEventListener(type, callback, !!useCapture);\n  };\n  /**\n   * Ajoute un écouteur d'évènement à tous les éléments qui correspondent au sélecteur passé dans la fonction.\n   * @param {element} target L'élément ciblé\n   *  @param {string} selector Le sélecteur css de l'élément ciblé\n   *  @param {string} seltypeector Le type de l'event\n   *  @param {string} handler Callback exécuté\n   */\n\n\n  window.$delegate = function (target, selector, type, handler) {\n    function dispatchEvent(event) {\n      let targetElement = event.target;\n      let potentialElements = window.qsa(selector, target);\n      let hasMatch = Array.prototype.indexOf.call(potentialElements, targetElement) >= 0;\n\n      if (hasMatch) {\n        handler.call(targetElement, event);\n      }\n    } // https://developer.mozilla.org/en-US/docs/Web/Events/blur\n\n\n    let useCapture = type === 'blur' || type === 'focus';\n    window.$on(target, type, dispatchEvent, useCapture);\n  };\n  /**\n   * Trouve l'élément parent qui porte le tag suivant : $parent(qs('a'), 'div');\n   * @param {element} element L'élément ciblé\n   *  @param {string} tagName Le sélecteur css de l'élément ciblé\n   */\n\n\n  window.$parent = function (element, tagName) {\n    if (!element.parentNode) {\n      return;\n    }\n\n    if (element.parentNode.tagName.toLowerCase() === tagName.toLowerCase()) {\n      return element.parentNode;\n    }\n\n    return window.$parent(element.parentNode, tagName);\n  }; // Autoriser la boucle sur les nœuds en chaînant:\n  // qsa('.foo').forEach(function () {})\n\n\n  NodeList.prototype.forEach = Array.prototype.forEach;\n})(window);\n\n//# sourceURL=webpack:///./src/javascript/helpers.js?");

/***/ }),

/***/ "./src/javascript/model.js":
/*!*********************************!*\
  !*** ./src/javascript/model.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function (window) {\n  'use strict';\n  /**\n   * MODEL Création d'une nouvelle instance de Model et intéraction avec la classe Store\n   * Crée une nouvelle instance de modèle et connecte le stockage.\n   * @constructor\n   * @param {object} storage Identifie la classe Store côté client.\n   */\n\n  class Model {\n    constructor(storage) {\n      this.storage = storage;\n    }\n    /**\n     * Créer un nouveau model de todo pour la tâche ajoutée\n     * @param {string} [title] Le titre de la tâche\n     * @param {function} [callback] La fonction appelé après que le model soit crée.\n     */\n\n\n    create(title, callback) {\n      title = title || '';\n\n      callback = callback || function () {};\n\n      let newItem = {\n        title: title.trim(),\n        completed: false\n      };\n      this.storage.save(newItem, callback);\n    }\n\n    /**\n     * Recherche et renvoie un modèle stocké. Si aucune requête n'est donnée, il sera simplement\n     * tout retourner. Si vous passez une chaîne ou un nombre, cela ressemblera à\n     * l'ID du modèle à trouver. Enfin, vous pouvez lui passer un objet pour correspondre\n     * contre.remove\n     * @param {string|number|object} [query] La requête pour filtrer les modèles\n     * @param {function} [callback] Une fonction de rappel à utiliser lorsqu'un model est trouvé\n     * \n     * Recherche et retourne un modèle stocké. Si aucune requête n'est donnée, tout sera simplement retourné. Si vous transmettez une chaîne ou un nombre, il le recherchera en tant qu'ID du modèle à rechercher. Enfin, vous pouvez lui transmettre un objet à comparer. Recherche et retourne dans le localStorage un model stocké. Si aucune requête n'est envoyée, tous les models seront renvoyés. Si la requête est une chaine de caractère ou un nombre, la méthode recherchera un id de model à retourner Il est aussi possible de passer un objet à comparer dans la requête.\n     * @example \n     * model.read(1, func); // Va chercher et trouver le modèle avec l'id 1\n     * model.read('1'); // Fera la même chose\n     *  Ci-dessous, un exemple avec foo égal à bar et hello égal à world\n     * model.read({ foo: 'bar', hello: 'world' });remove\n     */\n    read(query, callback) {\n      let queryType = typeof query;\n\n      callback = callback || function () {};\n\n      if (queryType === 'function') {\n        callback = query;\n        return this.storage.findAll(callback);\n      } else if (queryType === 'string' || queryType === 'number') {\n        query = parseInt(query, 10);\n        this.storage.find({\n          id: query\n        }, callback);\n      } else {\n        this.storage.find(query, callback);\n      }\n    }\n\n    /**\n     * Met à jour un modèle en lui attribuant un ID, des données à mettre à jour et une fonction de rappel appelée une fois la mise à jour terminée.\n     * @param {number} id L'id du model à mettre à jour\n     * @param {object} data Les données à mettre à jour et leurs nouvelles valeurs\n     * @param {function} callback La fonction de rappel utilisée après la mise à jour\n     */\n    update(id, data, callback) {\n      this.storage.save(data, callback, id);\n    }\n\n    /**\n     * Supprime un élément du stockage\n     * @param {number} id L'ID du modèle à supprimer\n     * @param {function} callback La fonction de rappel utilisée après la suppression\n     */\n    remove(id, callback) {\n      this.storage.remove(id, callback);\n    }\n\n    /**\n     * AVERTISSEMENT: Attention, cette méthode supprime tous les éléments du stockage\n     * @param {function} callback La fonction de rappel utilisée après la suppression\n     */\n    removeAll(callback) {\n      this.storage.drop(callback);\n    }\n\n    /**\n     * Retourne le nombre de todos\n     */\n    getCount(callback) {\n      let todos = {\n        active: 0,\n        completed: 0,\n        total: 0\n      };\n      this.storage.findAll(function (data) {\n        data.forEach(function (todo) {\n          if (todo.completed) {\n            todos.completed++;\n          } else {\n            todos.active++;\n          }\n\n          todos.total++;\n        });\n        callback(todos);\n      });\n    }\n\n  }\n\n  ; // Exporter vers window\n\n  window.app = window.app || {};\n  window.app.Model = Model;\n})(window);\n\n//# sourceURL=webpack:///./src/javascript/model.js?");

/***/ }),

/***/ "./src/javascript/store.js":
/*!*********************************!*\
  !*** ./src/javascript/store.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*jshint eqeqeq:false */\n(function (window) {\n  'use strict';\n  /**\n   * STORE Crée un nouvel objet Store côté client et créera un espace vide si aucun objet existe déja.\n   * @param {string} name Le nom de la base de donnée à utiliser\n   * @param {function} callback La fonction de rappel (seulement parce qu'on est en localStorage) utilisé après l'initialisation du Store. Dans le cas d'une vrai BDD, nous effecturions des appels AJAX.\n   */\n\n  class Store {\n    constructor(name, callback) {\n      callback = callback || function () {};\n\n      this._dbName = name;\n\n      if (!localStorage[name]) {\n        let data = {\n          todos: []\n        };\n        localStorage[name] = JSON.stringify(data);\n      }\n\n      callback.call(this, JSON.parse(localStorage[name]));\n    }\n    /**\n     * Trouve un élément en fonction de la requête (objet JS)\n     * @param {object} query La requête à comparer (par exemple {foo: 'bar'})\n     * @param {function} callback La fonction de rappel à utiliser lorsque le traitement de la requête est terminé\n     * @example\n     * db.find({foo: 'bar', hello: 'world'}, function (data) {\n     *\t // data will return any items that have foo: bar and\n     *\t // hello: world in their properties\n     * });\n     */\n\n\n    find(query, callback) {\n      // if (!callback) {\n      // \treturn;\n      // }\n      let todos = JSON.parse(localStorage[this._dbName]).todos;\n      callback.call(this, todos.filter(function (todo) {\n        for (let q in query) {\n          if (query[q] !== todo[q]) {\n            return false;\n          }\n        }\n\n        return true;\n      }));\n    }\n\n    /**\n     * Trouve tous les éléments présent dans le stockage\n     * @param {function} callback La fonction de rappel utilisée lorsque tous les éléments ont été trouvés\n     */\n    findAll(callback) {\n      callback = callback || function () {};\n\n      callback.call(this, JSON.parse(localStorage[this._dbName]).todos);\n    }\n\n    /**\n     * Sauvegarde les données dans la BDD. Si aucun élément n'existe, un nouveau élément sera créé, sinon une mise à jour des propriétés de l' élément existant sera réalisé\n     * @param {object} updateData L'objet data à sauvegarder dans la BDD\n     * @param {function} callback La fonction de rappel à utiliser après la sauvegarde\n     * @param {number} id L'id de l'élément à sauvegarder (facultatif)\n     */\n    save(updateData, callback, id) {\n      let data = JSON.parse(localStorage[this._dbName]);\n      let todos = data.todos;\n\n      callback = callback || function () {}; // Generer un ID\n\n\n      let newId = \"\";\n      let charset = \"0123456789\";\n\n      for (let i = 0; i < 6; i++) {\n        newId += charset.charAt(Math.floor(Math.random() * charset.length));\n      } // Si un ID a été donné, recherchez l'élément et mettez à jour chaque propriété\n\n\n      if (id) {\n        for (let i = 0; i < todos.length; i++) {\n          if (todos[i].id === id) {\n            for (let key in updateData) {\n              todos[i][key] = updateData[key];\n            }\n\n            break;\n          }\n        }\n\n        localStorage[this._dbName] = JSON.stringify(data);\n        callback.call(this, todos);\n      } else {\n        // Assigner un ID\n\n        /**\n         * Génére un identifiant unique\n         * @see  https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Date/now\n         * @example\n         * returns {number} 1519326977765\n         */\n        // updateData.id = parseInt(newId);\n        updateData.id = Date.now();\n        todos.push(updateData);\n        localStorage[this._dbName] = JSON.stringify(data);\n        callback.call(this, [updateData]);\n      }\n    }\n\n    /**\n     * Supprime un élément du stockage en se basant sur son ID\n     * @param {number} id L'id de l'élément à supprimer\n     * @param {function} callback La fonction de rappel utilisée après la suppression\n     */\n    remove(id, callback) {\n      let data = JSON.parse(localStorage[this._dbName]);\n      let todos = data.todos;\n      let todoId;\n\n      for (let i = 0; i < todos.length; i++) {\n        if (todos[i].id == id) {\n          todoId = todos[i].id;\n        }\n      }\n\n      for (let i = 0; i < todos.length; i++) {\n        if (todos[i].id == todoId) {\n          todos.splice(i, 1);\n        }\n      }\n\n      localStorage[this._dbName] = JSON.stringify(data);\n      callback.call(this, todos);\n    }\n\n    /**\n     * Démarre un nouveau stockage\n     * @param {function} callback La fonction de rappel utilisée après avoir envoyé les données\n     */\n    drop(callback) {\n      let data = {\n        todos: []\n      };\n      localStorage[this._dbName] = JSON.stringify(data);\n      callback.call(this, data.todos);\n    }\n\n  }\n\n  ; // Export to window\n\n  window.app = window.app || {};\n  window.app.Store = Store;\n})(window);\n\n//# sourceURL=webpack:///./src/javascript/store.js?");

/***/ }),

/***/ "./src/javascript/template.js":
/*!************************************!*\
  !*** ./src/javascript/template.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*jshint laxbreak:true */\n(function (window) {\n  'use strict';\n\n  let htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#x27;',\n    '`': '&#x60;'\n  };\n\n  let escapeHtmlChar = function (chr) {\n    return htmlEscapes[chr];\n  };\n\n  let reUnescapedHtml = /[&<>\"'`]/g;\n  let reHasUnescapedHtml = new RegExp(reUnescapedHtml.source);\n\n  let escape = function (string) {\n    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;\n  };\n  /**\n   * TEMPLATE Définit le template utilisé pour afficher les tâches\n   * @constructor\n   */\n\n\n  class Template {\n    constructor() {\n      this.defaultTemplate = '<li data-id=\"{{id}}\" class=\"{{completed}}\">' + '<div class=\"view\">' + '<input class=\"toggle\" type=\"checkbox\" {{checked}}>' + '<label>{{title}}</label>' + '<button class=\"destroy\"></button>' + '</div>' + '</li>';\n    }\n    /**\n     * Crée un élément HTML et place le template dans l'application. \n     * Normalement, il est conseillé d'utiliser un moteur de template comme Mustache ou Handlebars.\n     * Pour simplifier notre application, nous avons décidé de créer un template en vanilla JS.\n     * @param {object} data L'objet contenant les informations à remplacer dans le template.\n     * @returns {string} Chaîne HTML d'un élément <li> Le template HTML contenant l'élément\n     * @example\n     * view.show({\n     * id: 1, // l'id de la tâche\n     * title: \"Hello World\", // le titre de la tâche\n     * completed: 0, // la tâche est par défaut non terminée\n    });\n     */\n\n\n    show(data) {\n      let i, l;\n      let view = '';\n\n      for (i = 0, l = data.length; i < l; i++) {\n        let template = this.defaultTemplate;\n        let completed = '';\n        let checked = '';\n\n        if (data[i].completed) {\n          completed = 'completed';\n          checked = 'checked';\n        }\n\n        template = template.replace('{{id}}', data[i].id);\n        template = template.replace('{{title}}', escape(data[i].title));\n        template = template.replace('{{completed}}', completed);\n        template = template.replace('{{checked}}', checked);\n        view = view + template;\n      }\n\n      return view;\n    }\n\n    /**\n     * Affiche un compteur de tâches actives en bas à gauche de l'application\n     * @param {number} activeTodos Le nombre de tâches actives\n     * @returns {string} Chaîne contenant le nombre\n     */\n    itemCounter(activeTodos) {\n      let plural = activeTodos === 1 ? '' : 's';\n      return '<strong>' + activeTodos + '</strong> item' + plural + ' left';\n    }\n\n    /** \n     * Affiche ou non le bouton \"Clear Completed\" (si pas de tâches terminées = pas de bouton)\n     * @param  {Number} completedTodos Le nombre de tâche complétées\n     * @returns {string} Chaîne contenant le nombre\n     */\n    clearCompletedButton(completedTodos) {\n      if (completedTodos > 0) {\n        return 'Clear completed';\n      } else {\n        return ''; // RETURN itemCounterLa chaine de caractère contenant le texte du bouton.\n      }\n    }\n\n  }\n\n  ; // Export to window\n\n  window.app = window.app || {};\n  window.app.Template = Template;\n})(window);\n\n//# sourceURL=webpack:///./src/javascript/template.js?");

/***/ }),

/***/ "./src/javascript/view.js":
/*!********************************!*\
  !*** ./src/javascript/view.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*global qs, qsa, $on, $parent, $delegate */\n(function (window) {\n  'use strict';\n  /** \n   * VIEW Définit les valeurs par défaut du template ainsi que les intéractions avec le DOM (touches du clavier et évènements)\n   * @param {string} template template utilisé\n   */\n\n  class View {\n    constructor(template) {\n      this.template = template;\n      this.ENTER_KEY = 13;\n      this.ESCAPE_KEY = 27;\n      this.$todoList = qs('.todo-list');\n      this.$todoItemCounter = qs('.todo-count');\n      this.$clearCompleted = qs('.clear-completed');\n      this.$main = qs('.main');\n      this.$footer = qs('.footer');\n      this.$toggleAll = qs('.toggle-all');\n      this.$newTodo = qs('.new-todo');\n    }\n    /** \n     * Supprime une tâche de la liste\n     * @param {number} id L'id de la tâche à supprimer\n     */\n\n\n    _removeItem(id) {\n      let elem = qs('[data-id=\"' + id + '\"]');\n\n      if (elem) {\n        this.$todoList.removeChild(elem);\n      }\n    }\n\n    /** \n     * Affiche ou cache les éléments terminés\n     * @param {number} completedCount Le nombre d'éléments terminés\n     * @param {boolean} visible Les éléments sont-ils visibles ou non ?\n     */\n    _clearCompletedButton(completedCount, visible) {\n      this.$clearCompleted.innerHTML = this.template.clearCompletedButton(completedCount);\n      this.$clearCompleted.style.display = visible ? 'block' : 'none';\n    }\n\n    /** \n     * Affiche ou cache les éléments terminés\n     * @param {string} currentPage Le filtre appliqué : '' / active / completed\n     */\n    _setFilter(currentPage) {\n      qs('.filters .selected').className = '';\n      qs('.filters [href=\"#/' + currentPage + '\"]').className = 'selected';\n    }\n\n    /** \n     * Test si une tâche est terminée ou non\n     * @param {number} id L'id de la tâche à tester\n     * @param {boolean} completed La tâche est-elle terminée ou non ?\n     */\n    _elementComplete(id, completed) {\n      let listItem = qs('[data-id=\"' + id + '\"]'); // if (!listItem) {\n      // \treturn;\n      // }\n\n      listItem.className = completed ? 'completed' : ''; // Dans le cas où il a été basculé à partir d'un événement et non en cliquant sur la case à cocher\n\n      qs('input', listItem).checked = completed;\n    }\n\n    /** \n     * Editer une tâche dans la liste (grâce au double click)\n     * @param {number} id L'id de la tâche à éditer\n     * @param {string} title Le nouveau titre de la tâche\n     */\n    _editItem(id, title) {\n      let listItem = qs('[data-id=\"' + id + '\"]'); // if (!listItem) {\n      // \treturn;\n      // }\n\n      listItem.className = listItem.className + ' editing';\n      let input = document.createElement('input');\n      input.className = 'edit';\n      listItem.appendChild(input);\n      input.focus();\n      input.value = title;\n    }\n\n    /** \n     * Indique que l'édition d'une tâche est terminée\n     * @param {number} id L'id de la tâche qui était en édition\n     * @param {string} title Le nouveau titre de la tâche\n     */\n    _editItemDone(id, title) {\n      let listItem = qs('[data-id=\"' + id + '\"]'); // if (!listItem) {\n      // \treturn;\n      // }\n\n      let input = qs('input.edit', listItem);\n      listItem.removeChild(input);\n      listItem.className = listItem.className.replace('editing', '');\n      qsa('label', listItem).forEach(function (label) {\n        label.textContent = title;\n      });\n    }\n\n    /** \n     * Indique que l'édition d'une tâche est terminée\n     * @param {string} viewCmd La fonction active\n     * @param {object} parameter Les paramètres actifs\n     */\n    render(viewCmd, parameter) {\n      let self = this;\n      let viewCommands = {\n        showEntries: function () {\n          self.$todoList.innerHTML = self.template.show(parameter);\n        },\n        removeItem: function () {\n          self._removeItem(parameter);\n        },\n        updateElementCount: function () {\n          self.$todoItemCounter.innerHTML = self.template.itemCounter(parameter);\n        },\n        clearCompletedButton: function () {\n          self._clearCompletedButton(parameter.completed, parameter.visible);\n        },\n        contentBlockVisibility: function () {\n          self.$main.style.display = self.$footer.style.display = parameter.visible ? 'block' : 'none';\n        },\n        toggleAll: function () {\n          self.$toggleAll.checked = parameter.checked;\n        },\n        setFilter: function () {\n          self._setFilter(parameter);\n        },\n        clearNewTodo: function () {\n          self.$newTodo.value = '';\n        },\n        elementComplete: function () {\n          self._elementComplete(parameter.id, parameter.completed);\n        },\n        editItem: function () {\n          self._editItem(parameter.id, parameter.title);\n        },\n        editItemDone: function () {\n          self._editItemDone(parameter.id, parameter.title);\n        }\n      };\n      viewCommands[viewCmd]();\n    }\n\n    /** \n     * Définit les actions après l'édition d'une tâche\n     * @param {element} element La tâche dont on cherche l'id\n     * Return L'id de la tâche\n     */\n    _itemId(element) {\n      let li = $parent(element, 'li');\n      return parseInt(li.dataset.id, 10);\n    }\n\n    /** \n     * Définit les actions après l'édition d'une tâche\n     * @param {function} handler Fonction de rappel qui est exécutée lors de l'annulation de l'édition d'une tâche\n     */\n    _bindItemEditDone(handler) {\n      let self = this;\n      $delegate(self.$todoList, 'li .edit', 'blur', function () {\n        if (!this.dataset.iscanceled) {\n          handler({\n            id: self._itemId(this),\n            title: this.value\n          });\n        }\n      });\n      $delegate(self.$todoList, 'li .edit', 'keypress', function (event) {\n        if (event.keyCode === self.ENTER_KEY) {\n          // Retirez le curseur de l'entrée lorsque vous appuyez sur Entrée, comme s'il \n          // était une vraie forme\n          this.blur();\n        }\n      });\n    }\n\n    /** \n     * Définit les actions lorsque l'édition d'une tâche est annulée\n     * @param {function} handler Fonction de rappel qui est exécutée lors de l'annulation de l'édition d'une tâche\n     */\n    _bindItemEditCancel(handler) {\n      let self = this;\n      $delegate(self.$todoList, 'li .edit', 'keyup', function (event) {\n        if (event.keyCode === self.ESCAPE_KEY) {\n          this.dataset.iscanceled = true;\n          this.blur();\n          handler({\n            id: self._itemId(this)\n          });\n        }\n      });\n    }\n\n    /** \n     * Greffe des écouteurs d'évènements sur les tâches en fonction des actions de l'utilisateur, côté HTML\n     * @param {string} event L'event choisi\n     * @param {function} handler Fonctnion de rappel exécutée selon la situation\n     */\n    bind(event, handler) {\n      let self = this; // Amélioration\n      // Methode servant a binbder plusieur event: dans une logique d'amelioraztion, nous avons utiliser un traitement switch, qui est un peu plus maintenable et un peu plus lisible et plus performant.\n\n      switch (event) {\n        case 'newTodo':\n          $on(self.$newTodo, 'change', function () {\n            handler(self.$newTodo.value);\n          });\n          break;\n\n        case 'removeCompleted':\n          $on(self.$clearCompleted, 'click', function () {\n            handler();\n          });\n          break;\n\n        case 'toggleAll':\n          $on(self.$toggleAll, 'click', function () {\n            handler({\n              completed: this.checked\n            });\n          });\n          break;\n\n        case 'itemEdit':\n          $delegate(self.$todoList, 'li label', 'dblclick', function () {\n            handler({\n              id: self._itemId(this)\n            });\n          });\n          break;\n\n        case 'itemRemove':\n          $delegate(self.$todoList, '.destroy', 'click', function () {\n            handler({\n              id: self._itemId(this)\n            });\n          });\n          break;\n\n        case 'itemToggle':\n          $delegate(self.$todoList, '.toggle', 'click', function () {\n            handler({\n              id: self._itemId(this),\n              completed: this.checked\n            });\n          });\n          break;\n\n        case 'itemEditDone':\n          self._bindItemEditDone(handler);\n\n          break;\n\n        case 'itemEditCancel':\n          {\n            self._bindItemEditCancel(handler);\n          }\n      }\n    }\n\n  }\n\n  ; // Export to window\n\n  window.app = window.app || {};\n  window.app.View = View;\n})(window);\n\n//# sourceURL=webpack:///./src/javascript/view.js?");

/***/ })

/******/ });